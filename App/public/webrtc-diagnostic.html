<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Diagnostic Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        h2 {
            color: #3498db;
            margin-top: 20px;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fff;
        }
        .card-header {
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status.success {
            background-color: #2ecc71;
        }
        .status.warning {
            background-color: #f39c12;
        }
        .status.error {
            background-color: #e74c3c;
        }
        .info {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin: 10px 0;
        }
        .error-message {
            background-color: #fff3f3;
            border-left: 4px solid #e74c3c;
            padding: 10px;
            margin: 10px 0;
        }
        .success-message {
            background-color: #f0fff0;
            border-left: 4px solid #2ecc71;
            padding: 10px;
            margin: 10px 0;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        button.success {
            background-color: #2ecc71;
        }
        button.success:hover {
            background-color: #27ae60;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .log-area {
            height: 200px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin-top: 10px;
            font-family: monospace;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }
        .log-entry.error {
            color: #e74c3c;
        }
        .log-entry.warning {
            color: #f39c12;
        }
        .log-entry.success {
            color: #2ecc71;
        }
        .log-entry.info {
            color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC Diagnostic Tool</h1>
        
        <div class="card">
            <div class="card-header">Environment Information</div>
            <table id="environmentTable">
                <tr>
                    <td>Browser</td>
                    <td id="browserInfo">Loading...</td>
                </tr>
                <tr>
                    <td>WebRTC Support</td>
                    <td id="webrtcSupport">Checking...</td>
                </tr>
                <tr>
                    <td>Secure Context</td>
                    <td id="secureContext">Checking...</td>
                </tr>
                <tr>
                    <td>Socket Server</td>
                    <td id="socketServer">Not connected</td>
                </tr>
                <tr>
                    <td>Socket Path</td>
                    <td id="socketPath">Unknown</td>
                </tr>
                <tr>
                    <td>Socket Connection</td>
                    <td id="socketConnection">Not connected</td>
                </tr>
            </table>
            
            <div>
                <button id="refreshEnv">Refresh Environment Info</button>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">Socket Connection Test</div>
            <div>
                <button id="testSocketConnection">Test Socket Connection</button>
                <button id="disconnectSocket" class="danger">Disconnect Socket</button>
                <button id="reconnectSocket" class="success">Reconnect Socket</button>
            </div>
            <div id="socketTestResult" class="info">Click "Test Socket Connection" to begin the test.</div>
        </div>
        
        <div class="card">
            <div class="card-header">Media Devices</div>
            <table id="mediaDevicesTable">
                <thead>
                    <tr>
                        <th>Device Type</th>
                        <th>Device Name</th>
                        <th>Device ID</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="3">Loading devices...</td>
                    </tr>
                </tbody>
            </table>
            
            <div>
                <button id="refreshDevices">Refresh Devices</button>
                <button id="testCamera">Test Camera</button>
                <button id="testMicrophone">Test Microphone</button>
            </div>
            
            <div class="media-test-area" style="margin-top: 15px;">
                <video id="testVideo" width="320" height="240" style="background-color: #000; display: none;" autoplay muted></video>
                <canvas id="audioVisualizer" width="320" height="50" style="background-color: #000; display: none;"></canvas>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">Network Information</div>
            <table id="networkTable">
                <tr>
                    <td>IP Address</td>
                    <td id="ipAddress">Loading...</td>
                </tr>
                <tr>
                    <td>Connection Type</td>
                    <td id="connectionType">Unknown</td>
                </tr>
                <tr>
                    <td>Round Trip Time</td>
                    <td id="roundTripTime">Not tested</td>
                </tr>
            </table>
            
            <div>
                <button id="testNetwork">Test Network</button>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">Diagnostic Log</div>
            <div class="log-area" id="logArea"></div>
            <div style="margin-top: 10px;">
                <button id="clearLog">Clear Log</button>
                <button id="exportLog">Export Log</button>
            </div>
        </div>
    </div>
    
    <!-- Load required scripts with error handling -->
    <script>
        // Script loader with error handling
        function loadScript(src, onSuccess, onError) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = onSuccess;
            script.onerror = function(error) {
                console.error(`Failed to load script: ${src}`, error);
                if (onError) onError(error);
            };
            document.head.appendChild(script);
            return script;
        }
        
        // Load dependencies in order
        loadScript('https://cdn.socket.io/4.4.1/socket.io.min.js', function() {
            console.log('Socket.IO loaded successfully');
            
            // Now load webrtc-config.js
            loadScript('js/webrtc-modules/webrtc-config.js', function() {
                console.log('WebRTC config loaded successfully');
                
                // Finally load signaling.js
                loadScript('js/webrtc-modules/signaling.js', function() {
                    console.log('WebRTC signaling loaded successfully');
                    // Initialize the diagnostic tool
                    initDiagnosticTool();
                }, function() {
                    alert('Failed to load WebRTC signaling script. Check the console for details.');
                });
            }, function() {
                alert('Failed to load WebRTC config script. Check the console for details.');
            });
        }, function() {
            // Fallback to an older Socket.IO version if the first one fails
            console.warn('Failed to load Socket.IO 4.4.1, trying fallback version');
            loadScript('https://cdn.socket.io/4.1.2/socket.io.min.js', function() {
                console.log('Socket.IO fallback version loaded successfully');
                
                // Continue with the loading sequence
                loadScript('js/webrtc-modules/webrtc-config.js', function() {
                    console.log('WebRTC config loaded successfully');
                    
                    loadScript('js/webrtc-modules/signaling.js', function() {
                        console.log('WebRTC signaling loaded successfully');
                        initDiagnosticTool();
                    }, function() {
                        alert('Failed to load WebRTC signaling script. Check the console for details.');
                    });
                }, function() {
                    alert('Failed to load WebRTC config script. Check the console for details.');
                });
            }, function() {
                alert('Failed to load Socket.IO library. Check the console for details.');
            });
        });
    </script>
    <script>
        // Diagnostic tool functionality
        function initDiagnosticTool() {
            document.addEventListener('DOMContentLoaded', function() {
                // Create WebRTCUI if not available
                window.WebRTCUI = window.WebRTCUI || {
                    addLogEntry: function(msg, type) {
                        console.log(`[${type}] ${msg}`);
                    },
                    updateConnectionStatus: function(status, message) {
                        console.log(`Connection status: ${status} - ${message}`);
                    }
                };
                
                // Initialize logging
                const logArea = document.getElementById('logArea');
                
                function addLogEntry(message, type = 'info') {
                    const entry = document.createElement('div');
                    entry.className = `log-entry ${type}`;
                    const timestamp = new Date().toLocaleTimeString();
                    entry.textContent = `[${timestamp}] ${message}`;
                    logArea.appendChild(entry);
                    logArea.scrollTop = logArea.scrollHeight;
                    
                    // Also log to console
                    switch(type) {
                        case 'error': console.error(message); break;
                        case 'warning': console.warn(message); break;
                        case 'success': console.log('%c' + message, 'color: green'); break;
                        default: console.log(message);
                    }
                }
                
                // Initialize environment info
                function updateEnvironmentInfo() {
                    // Browser info
                    const browserInfo = document.getElementById('browserInfo');
                    browserInfo.textContent = `${navigator.userAgent}`;
                    
                    // WebRTC support
                    const webrtcSupport = document.getElementById('webrtcSupport');
                    const hasWebRTC = !!(navigator.mediaDevices && 
                                       navigator.mediaDevices.getUserMedia && 
                                       window.RTCPeerConnection);
                    webrtcSupport.innerHTML = hasWebRTC ? 
                        '<span class="status success"></span> Supported' : 
                        '<span class="status error"></span> Not supported';
                    
                    // Secure context
                    const secureContext = document.getElementById('secureContext');
                    const isSecure = window.isSecureContext || 
                                    window.location.protocol === 'https:' || 
                                    window.location.hostname === 'localhost' || 
                                    window.location.hostname === '127.0.0.1';
                    secureContext.innerHTML = isSecure ? 
                        '<span class="status success"></span> Yes' : 
                        '<span class="status error"></span> No - WebRTC requires HTTPS';
                    
                    // Socket server info
                    if (window.WebRTCConfig) {
                        const socketServer = document.getElementById('socketServer');
                        socketServer.textContent = window.WebRTCConfig.getSocketUrl();
                        
                        const socketPath = document.getElementById('socketPath');
                        socketPath.textContent = window.WebRTCConfig.getSocketOptions().path;
                    }
                    
                    // Socket connection status
                    updateSocketStatus();
                    
                    addLogEntry('Environment information updated', 'info');
                }
                
                // Update socket connection status
                function updateSocketStatus() {
                    const socketConnection = document.getElementById('socketConnection');
                    
                    if (window.WebRTCSignaling && window.WebRTCSignaling.isConnected()) {
                        const socketId = window.WebRTCSignaling.getSocketId();
                        socketConnection.innerHTML = `<span class="status success"></span> Connected (ID: ${socketId})`;
                    } else {
                        socketConnection.innerHTML = '<span class="status error"></span> Not connected';
                    }
                }
                
                // Test socket connection
                document.getElementById('testSocketConnection').addEventListener('click', function() {
                    const resultArea = document.getElementById('socketTestResult');
                    resultArea.className = 'info';
                    resultArea.textContent = 'Testing socket connection...';
                    
                    addLogEntry('Socket connection test started', 'info');
                    
                    // Initialize WebRTCSignaling if available
                    if (window.WebRTCSignaling && typeof window.WebRTCSignaling.initialize === 'function') {
                        window.WebRTCSignaling.initialize();
                    }
                    
                    // Connect to socket server
                    if (window.WebRTCSignaling && typeof window.WebRTCSignaling.connectToSignalingServer === 'function') {
                        try {
                            window.WebRTCSignaling.connectToSignalingServer(
                                'diagnostic-room',
                                'DiagnosticUser_' + Math.floor(Math.random() * 10000),
                                function onConnected(users) {
                                    resultArea.className = 'success-message';
                                    resultArea.textContent = `Socket connection successful! Socket ID: ${window.WebRTCSignaling.getSocketId()}`;
                                    updateSocketStatus();
                                    addLogEntry('Socket connection established successfully', 'success');
                                },
                                function onError(error) {
                                    resultArea.className = 'error-message';
                                    resultArea.textContent = `Socket connection failed: ${error}`;
                                    updateSocketStatus();
                                    addLogEntry(`Socket connection failed: ${error}`, 'error');
                                }
                            );
                        } catch (e) {
                            resultArea.className = 'error-message';
                            resultArea.textContent = `Error initializing socket: ${e.message}`;
                            addLogEntry(`Socket initialization error: ${e.message}`, 'error');
                        }
                    } else {
                        resultArea.className = 'error-message';
                        resultArea.textContent = 'WebRTCSignaling module not available';
                        addLogEntry('WebRTCSignaling module not available', 'error');
                    }
                });
                
                // Disconnect socket
                document.getElementById('disconnectSocket').addEventListener('click', function() {
                    if (window.WebRTCSignaling && window.WebRTCSignaling.getSocket()) {
                        const socket = window.WebRTCSignaling.getSocket();
                        if (socket && socket.connected) {
                            socket.disconnect();
                            addLogEntry('Socket manually disconnected', 'warning');
                            updateSocketStatus();
                        } else {
                            addLogEntry('Socket already disconnected', 'info');
                        }
                    } else {
                        addLogEntry('No socket connection available', 'warning');
                    }
                });
                
                // Reconnect socket
                document.getElementById('reconnectSocket').addEventListener('click', function() {
                    if (window.WebRTCSignaling && typeof window.WebRTCSignaling.reconnect === 'function') {
                        window.WebRTCSignaling.reconnect('diagnostic-room', 'DiagnosticUser_' + Math.floor(Math.random() * 10000));
                        addLogEntry('Socket reconnection initiated', 'info');
                        
                        // Check status after a delay
                        setTimeout(updateSocketStatus, 2000);
                    } else {
                        addLogEntry('WebRTCSignaling.reconnect not available', 'error');
                    }
                });
                
                // Refresh environment info
                document.getElementById('refreshEnv').addEventListener('click', updateEnvironmentInfo);
                
                // Media devices handling
                async function updateMediaDevices() {
                    const table = document.getElementById('mediaDevicesTable').querySelector('tbody');
                    table.innerHTML = '';
                    
                    // First check if mediaDevices API is available
                    if (!navigator.mediaDevices) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td colspan="3">Media devices API not supported in this browser.</td>`;
                        table.appendChild(row);
                        
                        // Update device test buttons
                        document.getElementById('testCamera').disabled = true;
                        document.getElementById('testCamera').title = 'Not supported in this browser';
                        document.getElementById('testMicrophone').disabled = true;
                        document.getElementById('testMicrophone').title = 'Not supported in this browser';
                        
                        addLogEntry('MediaDevices API not supported', 'error');
                        return;
                    }
                    
                    try {
                        // Request permission to access devices
                        await navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                            .then(stream => {
                                // Stop all tracks immediately after getting permission
                                stream.getTracks().forEach(track => track.stop());
                            })
                            .catch(err => {
                                addLogEntry(`Error accessing media devices: ${err.message}`, 'error');
                                
                                // Try with reduced constraints if initial request failed
                                return navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                                    .then(stream => {
                                        addLogEntry('Only audio devices available', 'warning');
                                        stream.getTracks().forEach(track => track.stop());
                                        
                                        // Disable camera test button
                                        document.getElementById('testCamera').disabled = true;
                                        document.getElementById('testCamera').title = 'Camera access denied';
                                    })
                                    .catch(err => {
                                        // Try video only
                                        return navigator.mediaDevices.getUserMedia({ audio: false, video: true })
                                            .then(stream => {
                                                addLogEntry('Only video devices available', 'warning');
                                                stream.getTracks().forEach(track => track.stop());
                                                
                                                // Disable microphone test button
                                                document.getElementById('testMicrophone').disabled = true;
                                                document.getElementById('testMicrophone').title = 'Microphone access denied';
                                            })
                                            .catch(err => {
                                                throw new Error('No media devices accessible');
                                            });
                                    });
                            });
                        
                        // Get devices list
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        
                        if (devices.length === 0) {
                            const row = document.createElement('tr');
                            row.innerHTML = '<td colspan="3">No media devices found</td>';
                            table.appendChild(row);
                            addLogEntry('No media devices found', 'warning');
                        } else {
                            devices.forEach(device => {
                                const row = document.createElement('tr');
                                
                                const typeCell = document.createElement('td');
                                typeCell.textContent = device.kind;
                                
                                const nameCell = document.createElement('td');
                                nameCell.textContent = device.label || 'Unnamed Device';
                                
                                const idCell = document.createElement('td');
                                idCell.textContent = device.deviceId.substring(0, 8) + '...';
                                idCell.title = device.deviceId;
                                
                                row.appendChild(typeCell);
                                row.appendChild(nameCell);
                                row.appendChild(idCell);
                                
                                table.appendChild(row);
                            });
                            
                            addLogEntry(`Found ${devices.length} media devices`, 'success');
                        }
                    } catch (e) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td colspan="3">Error accessing media devices: ${e.message}</td>`;
                        table.appendChild(row);
                        addLogEntry(`Error enumerating media devices: ${e.message}`, 'error');
                    }
                }
                
                // Refresh media devices
                document.getElementById('refreshDevices').addEventListener('click', updateMediaDevices);
                
                // Test camera
                document.getElementById('testCamera').addEventListener('click', async function() {
                    const videoElement = document.getElementById('testVideo');
                    
                    // Stop any existing streams
                    if (videoElement.srcObject) {
                        videoElement.srcObject.getTracks().forEach(track => track.stop());
                    }
                    
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        videoElement.srcObject = stream;
                        videoElement.style.display = 'block';
                        addLogEntry('Camera test started', 'info');
                        
                        // Add stop button
                        const stopButton = document.createElement('button');
                        stopButton.textContent = 'Stop Camera';
                        stopButton.className = 'danger';
                        stopButton.style.marginTop = '10px';
                        stopButton.onclick = function() {
                            if (videoElement.srcObject) {
                                videoElement.srcObject.getTracks().forEach(track => track.stop());
                            }
                            videoElement.style.display = 'none';
                            this.remove();
                            addLogEntry('Camera test stopped', 'info');
                        };
                        
                        videoElement.parentNode.insertBefore(stopButton, videoElement.nextSibling);
                    } catch (e) {
                        addLogEntry(`Camera test failed: ${e.message}`, 'error');
                    }
                });
                
                // Test microphone with visualizer
                document.getElementById('testMicrophone').addEventListener('click', async function() {
                    const canvas = document.getElementById('audioVisualizer');
                    let audioContext, analyser, dataArray, source;
                    let animationFrameId = null;
                    
                    // Clean up any previous test
                    if (window.microphoneStream) {
                        window.microphoneStream.getTracks().forEach(track => track.stop());
                    }
                    
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        window.microphoneStream = stream;
                        
                        // Create audio context
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioContext.createAnalyser();
                        source = audioContext.createMediaStreamSource(stream);
                        
                        source.connect(analyser);
                        // Don't connect to destination to avoid feedback
                        // analyser.connect(audioContext.destination);
                        
                        analyser.fftSize = 256;
                        const bufferLength = analyser.frequencyBinCount;
                        dataArray = new Uint8Array(bufferLength);
                        
                        canvas.style.display = 'block';
                        const canvasCtx = canvas.getContext('2d');
                        
                        // Add stop button
                        const stopButton = document.createElement('button');
                        stopButton.textContent = 'Stop Microphone';
                        stopButton.className = 'danger';
                        stopButton.style.marginTop = '10px';
                        stopButton.onclick = function() {
                            if (window.microphoneStream) {
                                window.microphoneStream.getTracks().forEach(track => track.stop());
                            }
                            canvas.style.display = 'none';
                            this.remove();
                            if (animationFrameId) {
                                cancelAnimationFrame(animationFrameId);
                                animationFrameId = null;
                            }
                            addLogEntry('Microphone test stopped', 'info');
                        };
                        
                        canvas.parentNode.insertBefore(stopButton, canvas.nextSibling);
                        
                        // Visualize audio
                        function draw() {
                            animationFrameId = requestAnimationFrame(draw);
                            
                            analyser.getByteFrequencyData(dataArray);
                            
                            canvasCtx.fillStyle = 'rgb(0, 0, 0)';
                            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            const barWidth = (canvas.width / bufferLength) * 2.5;
                            let barHeight;
                            let x = 0;
                            
                            for(let i = 0; i < bufferLength; i++) {
                                barHeight = dataArray[i] / 2;
                                
                                canvasCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                                canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                                
                                x += barWidth + 1;
                            }
                        }
                        
                        draw();
                        addLogEntry('Microphone test started', 'info');
                    } catch (e) {
                        addLogEntry(`Microphone test failed: ${e.message}`, 'error');
                    }
                });
                
                // Test network
                document.getElementById('testNetwork').addEventListener('click', async function() {
                    const ipAddress = document.getElementById('ipAddress');
                    const connectionType = document.getElementById('connectionType');
                    const roundTripTime = document.getElementById('roundTripTime');
                    
                    // Get connection type
                    if (navigator.connection) {
                        connectionType.textContent = navigator.connection.effectiveType || 'Unknown';
                        addLogEntry(`Connection type: ${navigator.connection.effectiveType || 'Unknown'}`, 'info');
                    } else {
                        connectionType.textContent = 'API not available';
                    }
                    
                    // Get IP address (using a public API)
                    try {
                        ipAddress.textContent = 'Fetching...';
                        const response = await fetch('https://api.ipify.org?format=json');
                        const data = await response.json();
                        ipAddress.textContent = data.ip;
                        addLogEntry(`IP address: ${data.ip}`, 'info');
                    } catch (e) {
                        ipAddress.textContent = 'Failed to retrieve';
                        addLogEntry(`Failed to get IP address: ${e.message}`, 'error');
                    }
                    
                    // Measure round trip time to socket server
                    if (window.WebRTCSignaling && window.WebRTCSignaling.isConnected()) {
                        roundTripTime.textContent = 'Measuring...';
                        
                        const startTime = Date.now();
                        const socket = window.WebRTCSignaling.getSocket();
                        
                        // Set timeout first to handle case where server doesn't respond to ping
                        const pingTimeout = setTimeout(() => {
                            if (roundTripTime.textContent === 'Measuring...') {
                                roundTripTime.textContent = 'Timeout';
                                addLogEntry('RTT measurement timed out', 'warning');
                            }
                        }, 5000);
                        
                        // Try standard Socket.IO ping first
                        socket.emit('ping');
                        
                        // Listen for pong response
                        const pongHandler = () => {
                            clearTimeout(pingTimeout);
                            const rtt = Date.now() - startTime;
                            roundTripTime.textContent = `${rtt}ms`;
                            addLogEntry(`Round trip time: ${rtt}ms`, 'info');
                            socket.off('pong', pongHandler);
                        };
                        
                        socket.once('pong', pongHandler);
                        
                        // Fallback: if no pong event in 1 second, try a custom ping
                        setTimeout(() => {
                            if (roundTripTime.textContent === 'Measuring...') {
                                addLogEntry('Standard ping failed, trying custom ping-test event', 'warning');
                                
                                // Try a custom ping event that might be implemented on the server
                                const newStartTime = Date.now();
                                socket.emit('ping-test', { timestamp: newStartTime });
                                
                                // Listen for custom response
                                socket.once('ping-test-response', (data) => {
                                    clearTimeout(pingTimeout);
                                    const rtt = Date.now() - newStartTime;
                                    roundTripTime.textContent = `${rtt}ms (custom)`;
                                    addLogEntry(`Round trip time (custom ping): ${rtt}ms`, 'info');
                                });
                            }
                        }, 1000);
                        
                        // No need for another timeout since we already have one above
                    } else {
                        roundTripTime.textContent = 'Socket not connected';
                        addLogEntry('Cannot measure RTT: Socket not connected', 'warning');
                    }
                });
                
                // Clear log
                document.getElementById('clearLog').addEventListener('click', function() {
                    logArea.innerHTML = '';
                    addLogEntry('Log cleared', 'info');
                });
                
                // Export log
                document.getElementById('exportLog').addEventListener('click', function() {
                    const logText = Array.from(logArea.childNodes)
                        .map(node => node.textContent)
                        .join('\n');
                    
                    const blob = new Blob([logText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `webrtc-diagnostic-log-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    addLogEntry('Log exported', 'success');
                });
                
                // Initialize
                addLogEntry('WebRTC Diagnostic Tool initialized', 'info');
                updateEnvironmentInfo();
                updateMediaDevices();
            });
        }
    </script>
</body>
</html> 