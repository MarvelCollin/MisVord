#!/bin/bash

# Exit on error
set -e

# Define colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Starting MiscVord VPS Deployment Process...${NC}"
echo -e "${BLUE}This script will ALWAYS configure for VPS deployment to marvelcollin.my.id${NC}"

# Force VPS mode regardless of environment
IS_VPS=true
DOMAIN="marvelcollin.my.id"
USE_HTTPS=true
SUBPATH="misvord"

echo -e "${GREEN}VPS deployment configuration:${NC}"
echo -e "  ${BLUE}• Domain:${NC} $DOMAIN"
echo -e "  ${BLUE}• HTTPS:${NC} Enabled"
echo -e "  ${BLUE}• Subpath:${NC} /$SUBPATH"

# Confirm with user
read -p "Continue with these settings? (y/n, default: y): " confirm
if [[ $confirm =~ ^[Nn] ]]; then
    echo -e "${YELLOW}Deployment canceled.${NC}"
    exit 0
fi

# Create environment file
echo -e "${YELLOW}Creating environment configuration for VPS deployment...${NC}"

# Create .env file with VPS settings
cat > .env << EOL
# MiscVord environment configuration
# Auto-generated by deploy.sh for VPS deployment on $(date)

# Basic environment configuration
APP_ENV=production
APP_DEBUG=false

# Docker ports configuration
APP_PORT=80
SOCKET_PORT=1002
SOCKET_SECURE_PORT=1443
DB_PORT=1003
PMA_PORT=1004
ADMINER_PORT=1005

# Database configuration
DB_HOST=db
DB_NAME=misvord
DB_USER=root
DB_PASS=password
DB_CHARSET=utf8mb4

# Socket server configuration
SOCKET_SERVER=https://${DOMAIN}/${SUBPATH}/socket
SOCKET_SERVER_LOCAL=http://localhost:1002
SOCKET_PATH=/${SUBPATH}/socket/socket.io
SOCKET_API_KEY=kolin123
CORS_ALLOWED_ORIGINS=https://${DOMAIN}

# VPS deployment specific - FORCED
IS_VPS=true
USE_HTTPS=true
DOMAIN=${DOMAIN}
SUBPATH=${SUBPATH}
EOL

echo -e "${GREEN}VPS environment configuration created!${NC}"
echo -e "${YELLOW}Configuration summary:${NC}"
echo -e "  ${BLUE}• Environment:${NC} Production VPS"
echo -e "  ${BLUE}• APP_ENV:${NC} production"
echo -e "  ${BLUE}• IS_VPS:${NC} true"
echo -e "  ${BLUE}• Domain:${NC} $DOMAIN"
echo -e "  ${BLUE}• HTTPS:${NC} Enabled"
echo -e "  ${BLUE}• Subpath:${NC} /$SUBPATH"
echo -e "  ${BLUE}• Socket Path:${NC} /$SUBPATH/socket/socket.io"
echo -e "  ${BLUE}• App Port:${NC} 80"

# Check for docker-compose
if ! command -v docker-compose &> /dev/null; then
    if ! command -v docker compose &> /dev/null; then
        echo -e "${RED}Docker Compose not found! Please install Docker Compose.${NC}"
        exit 1
    else
        DOCKER_COMPOSE="docker compose"
    fi
else
    DOCKER_COMPOSE="docker-compose"
fi

# Ask user if they want to start containers
read -p "Do you want to build and start containers now? (y/n, default: y): " start_containers
if [[ -z "$start_containers" || "$start_containers" =~ ^[Yy] ]]; then
    echo -e "${YELLOW}Building and starting containers for VPS deployment...${NC}"
    $DOCKER_COMPOSE down
    $DOCKER_COMPOSE build --no-cache
    $DOCKER_COMPOSE up -d

    echo -e "${GREEN}VPS deployment completed successfully!${NC}"

    # Check container status
    echo -e "${YELLOW}Container status:${NC}"
    $DOCKER_COMPOSE ps
else
    echo -e "${YELLOW}Container build skipped. Run '$DOCKER_COMPOSE up -d' manually when ready.${NC}"
fi

# Generate NGINX configuration for VPS
echo -e "\n${YELLOW}=== NGINX CONFIGURATION FOR ${DOMAIN} ===${NC}"
echo -e "Add the following to your NGINX server block:\n"

cat << EOF
server {
    listen 443 ssl;
    server_name ${DOMAIN};
    
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    
    # Main application under /${SUBPATH}
    location /${SUBPATH}/ {
        proxy_pass http://localhost:${APP_PORT:-80}/;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    # Socket server under /${SUBPATH}/socket
    location /${SUBPATH}/socket/ {
        proxy_pass http://localhost:${SOCKET_PORT}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
    }

    # Socket.IO specific path for connections
    location /${SUBPATH}/socket/socket.io/ {
        proxy_pass http://localhost:${SOCKET_PORT}/socket.io/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
    }
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name ${DOMAIN};
    return 301 https://\$host\$request_uri;
}
EOF

echo -e "\n${YELLOW}Next steps:${NC}"
echo -e "1. Add the NGINX configuration above to your server"
echo -e "2. Ensure you have SSL certificates for ${DOMAIN}"
echo -e "   If not, obtain them using: ${BLUE}sudo certbot --nginx -d ${DOMAIN}${NC}"
echo -e "3. Reload NGINX: ${BLUE}sudo systemctl reload nginx${NC}"
echo -e "4. Test your WebSocket connection: ${BLUE}sh check-websocket.sh${NC}"
echo -e "5. Access your application at: ${BLUE}https://${DOMAIN}/${SUBPATH}/${NC}" 