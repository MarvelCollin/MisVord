#!/bin/bash

# Exit on error - only at a global level, we'll handle errors in functions
set -e

# Define colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Log file for deployment
LOG_FILE="deploy_$(date +%Y%m%d_%H%M%S).log"

# Function to log messages
log_message() {
    local message="$1"
    local level="${2:-INFO}"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo "$timestamp [$level] $message" >> "$LOG_FILE"
}

# Function to display a step with proper formatting
show_step() {
    echo -e "\n${YELLOW}▶ $1${NC}"
    log_message "STEP: $1" "STEP"
}

# Function to display success message
show_success() {
    echo -e "${GREEN}✓ $1${NC}"
    log_message "$1" "SUCCESS"
}

# Function to display error message
show_error() {
    echo -e "${RED}✗ $1${NC}"
    log_message "$1" "ERROR"
}

# Function to display warning message
show_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
    log_message "$1" "WARNING"
}

# Function to display info message
show_info() {
    echo -e "${BLUE}ℹ $1${NC}"
    log_message "$1" "INFO"
}

# Function to handle errors
handle_error() {
    local exit_code=$?
    local line_number=$1
    show_error "Error occurred at line $line_number with exit code $exit_code"
    show_error "Check the log file at $LOG_FILE for details"
    
    if [[ -n "$2" && "$2" == "continue" ]]; then
        show_warning "Continuing despite errors..."
    else
        show_error "Deployment failed!"
        exit $exit_code
    fi
}

# Function to check and create environment file
create_environment_file() {
    show_step "Creating environment configuration for VPS deployment..."
    
    # Create .env file with VPS settings
    cat > .env << EOL
# MiscVord environment configuration
# Auto-generated by deploy.sh for VPS deployment on $(date)

# Basic environment configuration
APP_ENV=production
APP_DEBUG=false

# Docker ports configuration
# Each service uses the same port number for both host and container
APP_PORT=1001
SOCKET_PORT=1002
SOCKET_SECURE_PORT=1443
DB_PORT=1003
PMA_PORT=1004
ADMINER_PORT=1005

# Database configuration
DB_HOST=db
DB_NAME=misvord
DB_USER=root
DB_PASS=password
DB_CHARSET=utf8mb4

# Socket server configuration
SOCKET_SERVER=https://${DOMAIN}/${SUBPATH}/socket
SOCKET_SERVER_LOCAL=http://localhost:1002
SOCKET_PATH=/${SUBPATH}/socket/socket.io
SOCKET_API_KEY=kolin123
CORS_ALLOWED_ORIGINS=https://${DOMAIN}

# VPS deployment specific - FORCED
IS_VPS=true
USE_HTTPS=true
DOMAIN=${DOMAIN}
SUBPATH=${SUBPATH}
EOL

    if [ $? -eq 0 ]; then
        show_success "VPS environment configuration created!"
    else
        show_error "Failed to create environment configuration"
        return 1
    fi

    show_info "Configuration summary:"
    echo -e "  ${BLUE}• Environment:${NC} Production VPS"
    echo -e "  ${BLUE}• APP_ENV:${NC} production"
    echo -e "  ${BLUE}• IS_VPS:${NC} true"
    echo -e "  ${BLUE}• Domain:${NC} $DOMAIN"
    echo -e "  ${BLUE}• HTTPS:${NC} Enabled"
    echo -e "  ${BLUE}• Subpath:${NC} /$SUBPATH"
    echo -e "  ${BLUE}• Socket Path:${NC} /$SUBPATH/socket/socket.io"
    echo -e "  ${BLUE}• App Port:${NC} 1001"
    echo -e "  ${BLUE}• Socket Port:${NC} 1002"
    echo -e "  ${BLUE}• DB Port:${NC} 1003"
    echo -e "  ${BLUE}• PHPMyAdmin Port:${NC} 1004"
    echo -e "  ${BLUE}• Adminer Port:${NC} 1005"

    return 0
}

# Function to check Docker Compose
check_docker_compose() {
    show_step "Checking Docker Compose availability..."
    
    if ! command -v docker-compose &> /dev/null; then
        if ! command -v docker compose &> /dev/null; then
            show_error "Docker Compose not found! Please install Docker Compose."
            return 1
        else
            DOCKER_COMPOSE="docker compose"
            show_success "Found Docker Compose (new style command: 'docker compose')"
        fi
    else
        DOCKER_COMPOSE="docker-compose"
        show_success "Found Docker Compose (old style command: 'docker-compose')"
    fi

    # Export the variable for use in other functions
    export DOCKER_COMPOSE
    return 0
}

# Function to build and start Docker containers
build_and_start_containers() {
    show_step "Building and starting containers for VPS deployment..."
    
    # Stop any running containers
    show_info "Stopping any running containers..."
    $DOCKER_COMPOSE down || {
        show_error "Failed to stop containers"
        return 1
    }
    
    # Build containers
    show_info "Building containers (this might take a while)..."
    $DOCKER_COMPOSE build --no-cache || {
        show_error "Failed to build containers"
        return 1
    }
    
    # Start containers
    show_info "Starting containers..."
    $DOCKER_COMPOSE up -d || {
        show_error "Failed to start containers"
        return 1
    }
    
    show_success "Containers started successfully!"
    
    # Check container status
    show_info "Container status:"
    $DOCKER_COMPOSE ps || {
        show_warning "Could not get container status"
    }

    # Check for any container not in "Up" state
    local failed_containers=$($DOCKER_COMPOSE ps | grep -v "Up" | grep -v "Name" | wc -l)
    if [ "$failed_containers" -gt 0 ]; then
        show_warning "$failed_containers container(s) may not be running correctly!"
        show_info "Checking logs for potential issues..."
        $DOCKER_COMPOSE logs --tail=50
        return 1
    fi

    return 0
}

# Function to create NGINX configuration
create_nginx_config() {
    show_step "Checking NGINX configuration..."
    
    NGINX_CONFIG_PATH="nginx-config.conf"

    if [ -f "$NGINX_CONFIG_PATH" ]; then
        show_success "Found existing NGINX configuration: $NGINX_CONFIG_PATH"
        show_info "Checking if configuration is suitable for WebSocket connections..."
        
        # Check if configuration contains required WebSocket settings
        if grep -q "proxy_set_header Upgrade \$http_upgrade" "$NGINX_CONFIG_PATH" && 
           grep -q "proxy_set_header Connection \"upgrade\"" "$NGINX_CONFIG_PATH" &&
           grep -q "location /${SUBPATH}/socket/socket.io/" "$NGINX_CONFIG_PATH"; then
            show_success "Configuration contains WebSocket proxying settings"
            NGINX_CONFIG_FILE=$NGINX_CONFIG_PATH
        else
            show_warning "Existing configuration may not contain proper WebSocket settings"
            echo -e "${YELLOW}Would you like to update it with optimized WebSocket settings?${NC}"
            read -p "This is recommended for WebSocket support (y/n, default: y): " update_config
            
            if [[ -z "$update_config" || "$update_config" =~ ^[Yy] ]]; then
                show_info "Making a backup of the existing configuration..."
                cp "$NGINX_CONFIG_PATH" "${NGINX_CONFIG_PATH}.backup"
                show_success "Backup saved to ${NGINX_CONFIG_PATH}.backup"
                
                show_info "Updating NGINX configuration with optimized WebSocket settings..."
                update_nginx_with_websocket_support
                NGINX_CONFIG_FILE=$NGINX_CONFIG_PATH
            else
                show_warning "Using existing configuration without changes. WebSocket may not work correctly."
                NGINX_CONFIG_FILE=$NGINX_CONFIG_PATH
            fi
        fi
    else
        show_warning "No existing NGINX configuration found. Generating new one..."
        NGINX_CONFIG_FILE="${SUBPATH}.conf"
        create_new_nginx_config
    fi
    
    show_success "NGINX configuration ready: $NGINX_CONFIG_FILE"
    return 0
}

# Function to update NGINX with WebSocket support
update_nginx_with_websocket_support() {
    # Reading only the contents we want to keep
    local server_blocks=$(awk '/server {/,/}/' "$NGINX_CONFIG_PATH")
    
    # Create a new temporary file
    local temp_file="${NGINX_CONFIG_PATH}.new"
    
    # Write to the temporary file
    cat > "$temp_file" << EOF
# MiscVord NGINX Configuration - Optimized for WebSocket
# Updated by deploy.sh on $(date)

server {
    listen 80;
    server_name ${DOMAIN};

    # Redirect everything on HTTP to HTTPS
    location / {
        return 301 https://\$host\$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name ${DOMAIN} www.${DOMAIN};

    # SSL certificate configuration
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    
    # SSL optimization
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # Main application under /${SUBPATH}
    location /${SUBPATH}/ {
        proxy_pass http://localhost:1001/;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
    }

    # Static assets with caching
    location ~* ^/${SUBPATH}/(css|js|assets)/(.*) {
        proxy_pass http://localhost:1001/\$1/\$2;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_valid 200 1d;
        add_header Cache-Control "public, max-age=86400";
    }

    # Socket server under /${SUBPATH}/socket - CRITICAL FOR WEBSOCKET
    location /${SUBPATH}/socket/ {
        proxy_pass http://localhost:1002/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Ssl on;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        
        # CORS headers for WebSocket
        add_header 'Access-Control-Allow-Origin' 'https://${DOMAIN}' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
    }

    # Socket.IO specific path - CRITICAL PATH FOR SOCKET.IO CONNECTION
    location /${SUBPATH}/socket/socket.io/ {
        proxy_pass http://localhost:1002/socket.io/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Ssl on;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        
        # CORS headers for WebSocket
        add_header 'Access-Control-Allow-Origin' 'https://${DOMAIN}' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
    }

    # PHPMyAdmin under /${SUBPATH}/pma
    location /${SUBPATH}/pma/ {
        proxy_pass http://localhost:1004/;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    # Adminer under /${SUBPATH}/adminer
    location /${SUBPATH}/adminer/ {
        proxy_pass http://localhost:1005/;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
    
    # Redirect root to /${SUBPATH}
    location = / {
        return 301 /${SUBPATH}/;
    }

    # Enable gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_min_length 1000;
    gzip_comp_level 6;
    gzip_proxied any;
    gzip_vary on;
}
EOF

    # Replace the original file with the new one
    mv "$temp_file" "$NGINX_CONFIG_PATH"
    show_success "NGINX configuration updated with optimized WebSocket settings"
}

# Function to create a new NGINX config
create_new_nginx_config() {
    cat > $NGINX_CONFIG_FILE << EOF
# MiscVord NGINX Configuration - Generated by deploy.sh on $(date)

server {
    listen 80;
    server_name ${DOMAIN};

    # Redirect everything on HTTP to HTTPS
    location / {
        return 301 https://\$host\$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name ${DOMAIN} www.${DOMAIN};

    # SSL certificate configuration
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    
    # Main application under /${SUBPATH}
    location /${SUBPATH}/ {
        proxy_pass http://localhost:1001/;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
    }

    # Socket server under /${SUBPATH}/socket - CRITICAL FOR WEBSOCKET
    location /${SUBPATH}/socket/ {
        proxy_pass http://localhost:1002/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Ssl on;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        
        # CORS headers for WebSocket
        add_header 'Access-Control-Allow-Origin' 'https://${DOMAIN}' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
    }

    # Socket.IO specific path - CRITICAL FOR SOCKET.IO CONNECTION
    location /${SUBPATH}/socket/socket.io/ {
        proxy_pass http://localhost:1002/socket.io/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Ssl on;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 86400;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        
        # CORS headers for WebSocket
        add_header 'Access-Control-Allow-Origin' 'https://${DOMAIN}' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
    }

    # Redirect root to /${SUBPATH}
    location = / {
        return 301 /${SUBPATH}/;
    }
}
EOF

    show_success "New NGINX configuration file created: $NGINX_CONFIG_FILE"
}

# Function to install NGINX configuration
install_nginx_config() {
    show_step "Installing NGINX configuration..."
    
    # Check if sudo is available
    if ! command -v sudo &> /dev/null; then
        show_error "sudo is not available. Cannot install NGINX configuration."
        return 1
    fi
    
    # Check if this is using the existing config
    if [ "$NGINX_CONFIG_FILE" = "$NGINX_CONFIG_PATH" ]; then
        NGINX_DEST="/etc/nginx/sites-available/marvelcollin.my.id.conf"
        show_info "Installing existing configuration to $NGINX_DEST..."
    else
        NGINX_DEST="/etc/nginx/sites-available/${NGINX_CONFIG_FILE}"
        show_info "Installing new configuration to $NGINX_DEST..."
    fi
    
    # Check for SSL certificates
    if [ ! -d "/etc/letsencrypt/live/${DOMAIN}" ]; then
        show_warning "SSL certificates for ${DOMAIN} not found."
        echo -e "${YELLOW}Would you like to generate them now?${NC}"
        echo -e "${CYAN}This requires sudo privileges and certbot installed${NC}"
        read -p "Generate SSL certificates? (y/n, default: y): " gen_ssl
        
        if [[ -z "$gen_ssl" || "$gen_ssl" =~ ^[Yy] ]]; then
            show_info "Generating SSL certificates with certbot..."
            sudo certbot --nginx -d ${DOMAIN} || {
                show_error "Failed to generate SSL certificates!"
                return 1
            }
        else
            show_warning "Continuing without SSL certificates. HTTPS will not work correctly."
        fi
    else
        show_success "SSL certificates for ${DOMAIN} already exist."
    fi
    
    # Copy NGINX config to sites-available
    sudo cp $NGINX_CONFIG_FILE $NGINX_DEST || {
        show_error "Failed to copy NGINX configuration to sites-available!"
        return 1
    }

    # Create symlink in sites-enabled if it doesn't exist
    if [ ! -f "/etc/nginx/sites-enabled/$(basename $NGINX_DEST)" ]; then
        sudo ln -s $NGINX_DEST /etc/nginx/sites-enabled/ || {
            show_error "Failed to create symlink in sites-enabled!"
            return 1
        }
        show_success "Created symlink in sites-enabled"
    else
        show_success "Symlink in sites-enabled already exists"
    fi
    
    # Test NGINX config
    show_info "Testing NGINX configuration..."
    local nginx_test_output
    nginx_test_output=$(sudo nginx -t 2>&1)
    local nginx_test_status=$?
    
    # Log the output
    echo "$nginx_test_output" >> "$LOG_FILE"
    
    if [ $nginx_test_status -eq 0 ]; then
        show_success "NGINX configuration test passed!"
        
        # Reload NGINX
        show_info "Reloading NGINX..."
        sudo systemctl reload nginx || {
            show_error "Failed to reload NGINX!"
            return 1
        }
        
        show_success "NGINX configuration installed and reloaded successfully!"
    else
        show_error "NGINX configuration test failed!"
        echo -e "${RED}NGINX was not reloaded to prevent service disruption.${NC}"
        echo -e "${YELLOW}Output:${NC}\n${nginx_test_output}"
        return 1
    fi

    return 0
}

# Function to run WebSocket connection tests
test_websocket_connection() {
    show_step "Testing WebSocket connection..."
    
    # First check if our socket-server container is running
    show_info "Checking if socket-server container is running..."
    local socket_running
    socket_running=$($DOCKER_COMPOSE ps | grep socket-server | grep "Up" | wc -l)
    
    if [ "$socket_running" -lt 1 ]; then
        show_error "Socket server container is not running!"
        show_info "Container status:"
        $DOCKER_COMPOSE ps
        return 1
    else
        show_success "Socket server container is running"
    fi
    
    # Check socket server logs for startup
    show_info "Checking socket server logs for proper startup..."
    local socket_logs
    socket_logs=$($DOCKER_COMPOSE logs --tail=50 socket-server)
    echo "$socket_logs" >> "$LOG_FILE"
    
    # Check for critical environment variables in logs
    if echo "$socket_logs" | grep -q "environment for VPS deployment"; then
        show_success "Socket server detected VPS environment correctly"
    else
        show_warning "Socket server may not be configured for VPS deployment"
    fi
    
    # Check if the WebSocket check script exists
    if [ -f "check-websocket.sh" ]; then
        show_info "Running WebSocket check script..."
        bash check-websocket.sh
        
        # Check if curl is available
        if command -v curl &> /dev/null; then
            show_info "Testing socket server health endpoint..."
            local health_output
            health_output=$(curl -s http://localhost:1002/health)
            echo "Socket health response: $health_output" >> "$LOG_FILE"
            
            if echo "$health_output" | grep -q "healthy"; then
                show_success "Socket server health check passed!"
            else
                show_warning "Socket server health check response was unexpected"
            fi
        else
            show_warning "curl not available, skipping direct socket server tests"
        fi
    else
        show_warning "WebSocket check script not found, skipping WebSocket connection test"
    fi
    
    # Create a comprehensive WebSocket diagnostic report
    create_websocket_diagnostic_report
    
    return 0
}

# Function to create WebSocket diagnostic report
create_websocket_diagnostic_report() {
    local report_file="websocket_diagnostics_$(date +%Y%m%d_%H%M%S).txt"
    show_info "Creating comprehensive WebSocket diagnostic report: $report_file"
    
    echo "# MiscVord WebSocket Diagnostic Report" > "$report_file"
    echo "Generated: $(date)" >> "$report_file"
    echo "Domain: $DOMAIN" >> "$report_file"
    echo "Subpath: $SUBPATH" >> "$report_file"
    echo "" >> "$report_file"
    
    echo "## Container Status" >> "$report_file"
    $DOCKER_COMPOSE ps >> "$report_file" 2>&1
    echo "" >> "$report_file"
    
    echo "## Socket Server Logs" >> "$report_file"
    $DOCKER_COMPOSE logs --tail=100 socket-server >> "$report_file" 2>&1
    echo "" >> "$report_file"
    
    echo "## PHP App Logs" >> "$report_file"
    $DOCKER_COMPOSE logs --tail=20 php >> "$report_file" 2>&1
    echo "" >> "$report_file"
    
    echo "## Environment Variables" >> "$report_file"
    echo "IS_VPS: $IS_VPS" >> "$report_file"
    echo "DOMAIN: $DOMAIN" >> "$report_file"
    echo "SUBPATH: $SUBPATH" >> "$report_file"
    echo "USE_HTTPS: $USE_HTTPS" >> "$report_file"
    echo "" >> "$report_file"
    
    echo "## NGINX Configuration File" >> "$report_file"
    echo "Using: $NGINX_CONFIG_FILE" >> "$report_file"
    echo "Content:" >> "$report_file"
    cat "$NGINX_CONFIG_FILE" >> "$report_file" 2>&1
    echo "" >> "$report_file"
    
    echo "## Network Connectivity Tests" >> "$report_file"
    if command -v curl &> /dev/null; then
        echo "### Socket Server Health Check" >> "$report_file"
        curl -v http://localhost:1002/health >> "$report_file" 2>&1
        echo "" >> "$report_file"
        
        echo "### WebSocket Connection Test" >> "$report_file"
        echo "This would require a WebSocket client, showing curl connection instead:" >> "$report_file"
        curl -v http://localhost:1002/socket.io/ >> "$report_file" 2>&1
    else
        echo "curl not available, skipping connectivity tests" >> "$report_file"
    fi
    echo "" >> "$report_file"
    
    echo "## WebSocket Configuration" >> "$report_file"
    echo "Expected WebSocket path: /$SUBPATH/socket/socket.io/" >> "$report_file"
    echo "Expected WebSocket URL: wss://$DOMAIN/$SUBPATH/socket/socket.io/" >> "$report_file"
    echo "" >> "$report_file"
    
    echo "## Common Issues & Solutions" >> "$report_file"
    echo "1. Invalid namespace error: Check SOCKET_PATH in .env file" >> "$report_file"
    echo "2. Cross-Origin (CORS) error: Check CORS_ALLOWED_ORIGINS in .env file" >> "$report_file"
    echo "3. Connection refused: Check if port 1002 is open and socket-server is running" >> "$report_file"
    echo "4. SSL/certificate errors: Check SSL configuration in NGINX" >> "$report_file"
    echo "" >> "$report_file"
    
    show_success "Diagnostic report created: $report_file"
    show_info "If you encounter WebSocket issues, please check this report for details"
}

# Function to print deployment summary
print_deployment_summary() {
    show_step "Deployment Summary"
    
    echo -e "\n${GREEN}Deployment Complete!${NC}"
    echo -e "${BLUE}Your MiscVord app is now available at: https://${DOMAIN}/${SUBPATH}/${NC}"
    
    # Container status summary
    local running_containers=$($DOCKER_COMPOSE ps | grep "Up" | wc -l)
    echo -e "\n${BLUE}Container Status:${NC} $running_containers running"
    
    # Port configuration
    echo -e "\n${YELLOW}Port configuration:${NC}"
    echo -e "  ${BLUE}• Main app:${NC} http://localhost:1001"
    echo -e "  ${BLUE}• Socket server:${NC} http://localhost:1002"
    echo -e "  ${BLUE}• MySQL:${NC} localhost:1003"
    echo -e "  ${BLUE}• PHPMyAdmin:${NC} http://localhost:1004"
    echo -e "  ${BLUE}• Adminer:${NC} http://localhost:1005"
    
    # Check access
    echo -e "\n${YELLOW}Access URLs:${NC}"
    echo -e "  ${BLUE}• Main App:${NC} https://${DOMAIN}/${SUBPATH}/"
    echo -e "  ${BLUE}• WebSocket:${NC} wss://${DOMAIN}/${SUBPATH}/socket/socket.io/"
    echo -e "  ${BLUE}• PHPMyAdmin:${NC} https://${DOMAIN}/${SUBPATH}/pma/"
    echo -e "  ${BLUE}• Adminer:${NC} https://${DOMAIN}/${SUBPATH}/adminer/"
    
    # Log file location
    echo -e "\n${YELLOW}Deployment logs:${NC}"
    echo -e "  ${BLUE}• Main log:${NC} $LOG_FILE"
    if [ -f "websocket_diagnostics_$(date +%Y%m%d)*.txt" ]; then
        echo -e "  ${BLUE}• WebSocket diagnostics:${NC} websocket_diagnostics_*.txt"
    fi
    
    echo -e "\n${CYAN}If you encounter issues, check the diagnostic reports.${NC}"
}

# Main execution starts here
{
    # Initialize log file
    echo "=== MiscVord Deployment Log - $(date) ===" > "$LOG_FILE"
    echo "Domain: marvelcollin.my.id" >> "$LOG_FILE"
    log_message "Deployment script started" "START"

    echo -e "${MAGENTA}╔══════════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║        MiscVord VPS Deployment Script        ║${NC}"
    echo -e "${MAGENTA}╚══════════════════════════════════════════════╝${NC}"
    echo -e "${YELLOW}Starting MiscVord VPS Deployment Process...${NC}"
    echo -e "${BLUE}This script will ALWAYS configure for VPS deployment to marvelcollin.my.id${NC}"

    # Force VPS mode regardless of environment
    IS_VPS=true
    DOMAIN="marvelcollin.my.id"
    USE_HTTPS=true
    SUBPATH="misvord"

    echo -e "${GREEN}VPS deployment configuration:${NC}"
    echo -e "  ${BLUE}• Domain:${NC} $DOMAIN"
    echo -e "  ${BLUE}• HTTPS:${NC} Enabled"
    echo -e "  ${BLUE}• Subpath:${NC} /$SUBPATH"

    # Confirm with user
    read -p "Continue with these settings? (y/n, default: y): " confirm
    if [[ $confirm =~ ^[Nn] ]]; then
        show_warning "Deployment canceled by user."
        exit 0
    fi

    # Create environment file
    create_environment_file || {
        show_error "Failed to create environment file"
        exit 1
    }

    # Check Docker Compose
    check_docker_compose || {
        show_error "Docker Compose check failed"
        exit 1
    }

    # Ask user if they want to start containers
    read -p "Do you want to build and start containers now? (y/n, default: y): " start_containers
    if [[ -z "$start_containers" || "$start_containers" =~ ^[Yy] ]]; then
        build_and_start_containers || {
            show_warning "Some container(s) may not be running correctly!"
            log_message "Container build/start had issues" "WARNING"
            # Continue despite container issues
        }
    else
        show_warning "Container build skipped. Run '$DOCKER_COMPOSE up -d' manually when ready."
    fi

    # Create NGINX configuration
    create_nginx_config || {
        show_error "Failed to create NGINX configuration"
        exit 1
    }

    # Ask user if they want to install NGINX configuration
    echo -e "${YELLOW}Would you like to install the NGINX configuration?${NC}"
    read -p "This requires sudo privileges (y/n, default: y): " install_nginx

    if [[ -z "$install_nginx" || "$install_nginx" =~ ^[Yy] ]]; then
        install_nginx_config || {
            show_error "Failed to install NGINX configuration"
            # Continue despite NGINX issues since we may be in a non-sudo environment
            log_message "NGINX installation had issues" "WARNING"
        }
    else
        show_info "Manual NGINX installation:"
        echo -e "1. Copy the configuration file to your NGINX sites-available directory:"
        echo -e "   ${BLUE}sudo cp ${NGINX_CONFIG_FILE} /etc/nginx/sites-available/${NC}"
        echo -e "2. Create symlink: ${BLUE}sudo ln -s /etc/nginx/sites-available/$(basename $NGINX_CONFIG_FILE) /etc/nginx/sites-enabled/${NC}"
        echo -e "3. Test configuration: ${BLUE}sudo nginx -t${NC}"
        echo -e "4. Reload NGINX: ${BLUE}sudo systemctl reload nginx${NC}"
        echo -e "5. Test your WebSocket connection: ${BLUE}sh check-websocket.sh${NC}"
    fi

    # Test WebSocket connection
    test_websocket_connection || {
        show_warning "WebSocket connection test had issues"
        log_message "WebSocket connection test had issues" "WARNING"
    }

    # Print deployment summary
    print_deployment_summary

    log_message "Deployment script completed successfully" "END"

    echo -e "\n${GREEN}Deployment script completed successfully!${NC}"
    echo -e "${BLUE}See $LOG_FILE for detailed logs.${NC}\n"

} || {
    # This will catch any uncaught errors
    handle_error $LINENO
}

exit 0 